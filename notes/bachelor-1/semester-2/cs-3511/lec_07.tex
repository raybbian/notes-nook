\lecture{7}{Thu 01 Feb 2024 12:37}{BFS, Dijkstra}

\subsection{BFS}

Note that BFS is just DFS, but instead of processing the most recent node explored, we process the latest node explored. To find shortest paths, we can track the parent of each node, and go backwards.

\begin{theorem}
	BFS finds the shortest path.
\end{theorem}
\begin{proof}
	Let \( v_i \) be the vertices with distance \( i \) to the start point of BFS. We wish to show that BFS visits all vertices from \( v_i \) before visiting a vertex from \( v_{i+1} \). We proceed by induction on \( i \).
	\begin{description}
		\item[Base case] \( i=0 \). Then, \( v_0 \) is just the start point which is visited first.
		\item[Step case] \( i \to i + 1\). Let's look at BFS right after we finished visiting all vertices \( v_i \). Note that no vertices of distance \( v_{i+1} \) have been visited, which implies that no vertices of distance \( v_{i+2} \) has been enqueued, and all vertices from \( v_{i+1} \) are currently in the queue. Since we use a FIFO queue all of \( v_{i+1} \) must be visited before a vertex from \( v_{i+2} \). Furthermore, the edge we use to traverse to \( v_{i+1} \) requires that an edge \( (u, v_{i+1}) \) such that \( u \in v_i \).
	\end{description}
\end{proof}

However, what happens if we want to find the shortest path in a graph where there are edge weights?

\subsection{Dijkstra}
Instead of a first in first out queue, we use a priority queue. This allows us to process vertices in a way such that the cost to travel to that vertex is less. This is called Dijkstra's, and takes \( O(|E|\log |E|) \) time.

\begin{theorem}
	Dijkstra is optimal.
\end{theorem}
\begin{proof}
	Let \( d(v) \) be the length of the shortest path from \( s \) to \( v  \) for all \( v \in V\), where \( s \) is the start vertex. Assume the algorithm stores an incorrect value in the distance array. Let \( v_{1}, v_{2}, \ldots v_n \) be the vertices in the order in which they were visited by Dijkstra. Let \( v_i \) be the first vertex where \( d(v_i) \) is wrong. That means we used the wrong edge to go from \( v_{i-1} \) to \( v_i \). This means that \[
		d(v_i) = d(v_{i-1}) + w_{v_{i-1}v_i} > \text{shortest path to \( v_i \)}
	.\] Let \( a \) be a vertex with guaranteed correct distance, and \( b \) one otherwise. Assume that this path with \( a,b \) is the correct shortest path from \( s \) to \( v_i \). However, \( v_i \) was popped from the queue before \( b \). This means that the shortest path to \( b \) is \( \ge  \) the shortest path to \( v_i \). With some algebraic manipulation as well as asserting that there are no negative edge weights (check the lecture notes), then we have that the shortest path to \( v_i \) is strictly greater than the shortest path to \( v_i \), a contradiction. Therefore, there cannot exist such a \( v_i \).
\end{proof}
