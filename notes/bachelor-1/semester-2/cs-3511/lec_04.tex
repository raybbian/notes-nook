\lecture{4}{Thu 18 Jan 2024 12:35}{Divide and Conquer 3}

Note that arithmetic will take O(1) unless numbers blow up (grow exponentially).

Today we will cover a different version of binary search. One example of this version is binary search.

\begin{lstlisting}[language=Python]
def bin_search(arr, k):
	if n == 1:
		if arr[0] == k:
			return arr[0]
		else:
			raise Exception("")
		if a[n/2] < k:
			return bin_search(arr[n/2+1:], k)
		else:
			return bin_search(arr[:n/2], k)
\end{lstlisting}

By the master theorem, we have \( a=1, b=2, c=0 \) such that binary search runs in \( O(\log n) \) time. Another similar algorithm to binary search in which we only recurse into one spot is finding the \( k \)-th largest element in array, with a quickselect-type algorithm.

\begin{lstlisting}[language=Python]
def k_smallest(arr, k):
	p = A[rand()]
	smaller = []
	larger = []
	for i in range(n):
		if arr[i] <= p:
			smaller.append(arr[i])
		else:
			larger.append(arr[i])
	if smaller = k:
		return p
	if smaller < k:
		return k_smallest(larger, k - len(smaller))
	if smaller > k:
		return k_smallest(smaller, k)
\end{lstlisting}

If we can guarantee a good pivot \( \frac{3}{10}n \le \text{smaller} \le \frac{7}{10}n \), then the number of recursions is at most \( \log _{\frac{10}{7}}(n) = O(\log n) \). We can guarantee these goods pivots with the median of medians algorithm.

First, we split our array \( A \) into \( \frac{n}{5} \) groups, each of size 5. We can then sort each of these elements in ``constant'' time. Then, the median of each group is in the middle index of each 5. Now, we return the median of the array containing all medians. We can do this with recursion (divide and conquer), by calling ksmallest on it again.

We claim that the median of medians is a good \( p \). Imagine the upper left rectangular part of the median array. This is less than or equal to the median of medians. Same with the lower right rectangular part. Note that the number of elements in the rectangular parts are both \( \frac{3}{10} \). Therefore, \( p \) is at least the \( \frac{3}{10} \)-th element (same with the upper side).

Note that the median of medians algorithm takes constant time because sorting each of the 5 arrays is constant, so the sorting is linear. Then, selecting the median of the medians is also linear time, by a recursive call. We have a runtime of \[
	T(n) + T\left(\frac{n}{5}\right) + O(n) + T\left(\frac{7}{10}n\right) = O(n)
.\] Note that somehow, if we split into 3 groups, then the runtime is \( n\log n \). However, splitting into any odd number greater than 3 works.
